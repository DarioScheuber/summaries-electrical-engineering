# Datentypen 
## F-Strings
Wenn Sie bei normalen Strings Variablen einfügen wollen müssen Sie dies mühsam mit der String-Concats machen. Zusätzlich erlauben F-Strings das spezifizieren des gewünschten Formates. Die definition von F-Strings ist auch \textbf{schneller}.

``` python
normal_string = "string plus"+str(variabel)
print("string plus ",variabel)


f_string = f"string plus {variabel}"
print(f"string plus {variabel}")
``` 
::: callout-tip
Das kann auch mit mehreren Variablen gemacht werden
:::

``` python
#runden (4 stellen nach dem Komma)
pi = 3.141592653589793
print(f"{pi:.4f}")      #3.1415
#0-padding (5 stellen vor dem Komma)
print(f"{12:05}")       #00012
#binar 
print(f"{3:b}")         #11
#hex
print(f"{11:x}")        #b
#oktal
print(f"{11:o}")        #13
```
## Sequenzen
\textbf{unveränderbare Sequenzen (non-mutable)}
- Zeichenketten (Strings)
- Tuples 
    
Eigenschaften:
- keine neuen Elemente einfügbar
- Werte von Elementen nicht veränderbar

\textbf{Veränderbare Sequenzen (mutable)}
- Listen

Eigenschaften:
- neue Elemente können eingefügt werden
- Elemente können entfernen werden
- Werte von Elementen können verändert werden 

### Tuples
Tuples sind eine geordnete Sequenz von Elementen und verfügt deswegen über alle standard Sequenz-Funktionalitäten. Ein Tuple wird mit normalen Klammern ( ) definiert.
::: callout-note
Ein Tuple Elemente von verschiedenen Datentypen besitzen. Klammern sind optional.
:::
``` python
x = 1
my_tuple = (1,2,4,"word",x)
print(my_tuple[0])              #1
for elem in my_tuple:
    print(elem)                 #1
                                #2
                                #4
                                #...
1 in my_tuple                   #True
(1,2) in my_tuple               #False: (1,2) ist ein Tuple in einem Tuple
len(my_tuple)                   #5

my_tup = 1,2                    #Klammern optional
x,y = my_tup                    #x=1 y=2

```
::: callout-important
Aber Achtung Tuples sind nicht veränderbar!
:::
Falls jedoch \textbf{nicht alle Werte eines Tuples benötigt} werden, kann die \textbf{Tuple Entpackung} angewendet werden.
``` python
elem1 , *rest = my_tuple
print(elem1)                    #1
print(rest)                     #[2, 4, 'word', 1]

first, *middle, last = my_tuple
print(first)                    #1
print(middle)                   #[2, 4, 'word’] 
print(last)                     #1
```
::: callout-important
Hierbei sind die \textbf{Variabel Namen frei wählbar}, eine muss lediglich mit * beginnen.
::: 
### Listen
Eine Liste ist eine \textbf{veränderbare, geordnete Sequenz von Elementen.} Eine Liste kann einfach mit `[]` definiert werden.

``` python
my_list = [1,2,"String",2.0]
my_list[0]                      #1
for elem in my_list:            #1 2 String 2.0
1 in my_list                    #True
#Sind veränderbar
my_list[0] = "a"                #['a', 2, 'String', 2.0]
my_list[0:2] = [30,34]          #[30, 34, 'String', 2.0]
```
::: callout-important
Die Elemente in einer Liste können auch verschiedene Datentypen aufweisen.
::: 

#### Listen Funktionen
``` python
my_list = [1,2,3,4]

#Element Löschen
elem = my_list.pop(0)           #elem=1 my_list=[2,3,4]

#Element Hinzufügen am Ende
my_list.append(5)               #my_list=[2,3,4,5]

#Hinzufügen an einem Spezifischen Index
my_list.insert(0,"a")           #my_list=["a",2,3,4,5]

#Liste am Ende einer Liste anfügen
my_list.extend([1,2,3])         #my_list=["a",2,3,4,5,1,2,3]

#entfernt die erste Instanz von 1
my_list.remove(1)               #my_list=["a",2,3,4,5,2,3]

#alle Einträge einer Liste löschen
my_list.clear()
```
::: callout-important
Wenn value bei `.remove()` nicht in der Liste ist, gibt es einen Value_Error
:::

Wenn eine \textbf{Liste nur Zahlen} (`floats` und `ints`) beinhaltet kann diese ebenfalls mit `.sort()` der Grösse nach aufsteigen sortiert werden. Oder eine Liste \textbf{(Datentyp unabhängig)} kann mit `.reverse()` umgekehrt werden.
``` python
my_list = [5,3.0,2,1,10,30]
my_list.sort()              #[1, 2, 3.0, 5, 10, 30]
my_list.reverse()           #[30, 10, 5, 3.0, 2, 1]
```

#### List Copy by Reference 
``` python
my_list = [1,2,3]
my_list_2 = my_list
my_list_2[2] = 4
print(my_list)              #[1, 2, 4]
```
::: callout-important
### Copy by Reference 
Mutables werden mit Copy by Refernce kopiert das heisst das `my_list2` mithilfe eines Zeigers auf die Speicherstelle von `my_list` zeigt. Wenn `my_list2` geändert wird, ändert sich auch `my_list` und umgekehrt!
:::

Um richtig zu Kopieren gibt es die `.copy()` Methode.
``` python
my_list_2 = my_list.copy()
my_list_2[2] = 5
```
::: callout-note
Die `.copy()` Methode erzeugt ein neues Objekt im Speicher und weist die neue Variabel darauf zu.
:::

#### Mutable Default Values 
``` python
def add_to_list(item, list_to_add:list=None):
    if list_to_add is None:
        list_to_add = []
    ist_to_add.append(item)

    return list_to_add
```
::: callout-important
Wenn keine Liste übergeben wird, wird dies Detektiert. Darauf wird eine neue (leere) Liste erstellt.
:::

#### Listen und Schleifen 
Python unterstützt die sogenannte \textbf{List-Comprehension}, welche es erlaubt in einem 1-Zeiler Listen nach bestimmten Regeln zu erstellen.
``` python
#List erstellen mit Schleifen
my_list_2 = [i for i in range(10)]
#List erstellen mit Schleifen und einer Funktion
my_list = [my_func(elem) for elem in my_list_2]
#List erstellen mit Bedingungen
my_list = [elem**2 if elem%2==0 else elem for elem in my_list_2]
```
[\textcolor{green}{f(x)} if \textcolor{orange}{condition} else \textcolor{red}{g(x)} for x in sequence]

Heisst es wird \textcolor{green}{Funktion f(x)} auf jedes Element der Sequenz angewendet wenn die \textcolor{orange}{Bedingung} wahr ist. Ansonsten wird die \textcolor{red}{Funktion g(x)} angewendete.
